客户端和服务器端之间的通信
服务器端：
1）使用socket函数构建一个sockfd
2）调用bind函数将该sockfd与具体的协议地址相连，即具体的IP地址和port
3）使用listen函数进行监听
4）如果收到客户端的连接请求，使用accept函数接收客户端的连接请求，并产生新的sockfd
5）开始与客户端发送和接收消息
6）关闭与客户端连接的sockfd
7）关闭监听sockfd

客户端：
1）使用socket函数构建一个sockfd
2）使用connect函数尝试与服务器端相连接
3）开始用服务器端发送和接收消息
4）关闭该sockfd

关于一些常见socket函数的介绍
socket函数：int listenfd = socket(AF_INET, SOCK_STREAM, 0); 
bind函数：
    struct sockaddr_in serveraddr;
    serveraddr.sin_family = AF_INET;
    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);
    serveraddr.sin_port = htons(SERVER_PORT);
    if (connect(clientfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) == -1)

将文件描述符fd与具体的协议地址绑定上，即具体的IP地址 + port
INADDR_ANY：本机所有IP地址，相当于0.0.0.0 本机回环地址：127.0.0.1
服务器端的监听端口号一般是固定的，客户端的进程端口号一般是随机分配的，port是short型变量，0-65535 1024以下的是保留端口，用户程序不使用
1）当客户端使用bind将fd与o号端口绑定 没有影响
2）固定客户端端口号 只能调用一次connect 下一次调用时由于该端口已经使用了，不能connect

I/O复用中：select、poll、epoll的区别
select用来检测一组socket中是否有事件就绪。读事件 写事件 异常事件



线程池的原理和实现
https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/
原理：线程池就是一组线程。我们需要异步执行一些任务，这些任务存在于整个任务周期，与其让操作系统频繁为我们创建和销毁线程，不如创建一组在程序生命周期内不会退出的线程。
基本要求：当有任务需要执行时，线程可以自动拿到任务并执行，在没有任务到来时线程处于阻塞或者睡眠状态。
线程池的组成：任务队列 线程池 完成队列

实现步骤：
1）构造任务类和线程池类，线程池类中主要定义互斥量，用于互斥访问任务队列，条件变量，用于唤醒线程，线程数组，用于存储线程的sp，bool变量判断该线程池是否停止工作
2）初始化线程池中的线程数量 先构建一部分线程
3）处理函数中先将线程设置为待唤醒状态
4）向任务队列中条件任务，每次唤醒一个待唤醒的线程，进行处理
ps：这里要注意虚假唤醒的情况 while (m_taskList.empty()) {m_cv.wait(guard);} 要在while循环中等待信号，这样notify_one一个线程，可能多个竞争该唤醒条件的线程都会被唤醒，但是只有一个线程可以通过
while循环，开始处理
5）停止线程池工作 将bool变量设置为0 唤醒所有阻塞线程 并释放掉这些线程
6）remove掉所有的task
