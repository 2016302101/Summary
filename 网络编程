客户端和服务器端之间的通信
服务器端：
1）使用socket函数构建一个sockfd
2）调用bind函数将该sockfd与具体的协议地址相连，即具体的IP地址和port
3）使用listen函数进行监听
4）如果收到客户端的连接请求，使用accept函数接收客户端的连接请求，并产生新的sockfd
5）开始与客户端发送和接收消息
6）关闭与客户端连接的sockfd
7）关闭监听sockfd

客户端：
1）使用socket函数构建一个sockfd
2）使用connect函数尝试与服务器端相连接
3）开始用服务器端发送和接收消息
4）关闭该sockfd

I/O复用中：select、poll、epoll的区别

线程池的原理和实现
https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/
原理：线程池就是一组线程。我们需要异步执行一些任务，这些任务存在于整个任务周期，与其让操作系统频繁为我们创建和销毁线程，不如创建一组在程序生命周期内不会退出的线程。
基本要求：当有任务需要执行时，线程可以自动拿到任务并执行，在没有任务到来时线程处于阻塞或者睡眠状态。
线程池的组成：任务队列 线程池 完成队列

实现步骤：
1）构造任务类和线程池类，线程池类中主要定义互斥量，用于互斥访问任务队列，条件变量，用于唤醒线程，线程数组，用于存储线程的sp，bool变量判断该线程池是否停止工作
2）初始化线程池中的线程数量 先构建一部分线程
3）处理函数中先将线程设置为待唤醒状态
4）向任务队列中条件任务，每次唤醒一个待唤醒的线程，进行处理
ps：这里要注意虚假唤醒的情况 while (m_taskList.empty()) {m_cv.wait(guard);} 要在while循环中等待信号，这样notify_one一个线程，可能多个竞争该唤醒条件的线程都会被唤醒，但是只有一个线程可以通过
while循环，开始处理
5）停止线程池工作 将bool变量设置为0 唤醒所有阻塞线程 并释放掉这些线程
6）remove掉所有的task
