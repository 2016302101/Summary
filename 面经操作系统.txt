1 进程和线程的区别
进程是操作系统资源分配的基本单位，线程是CPU执行和调度的基本单位。
一个线程从属于一个进程，一个进程可以包含多个线程，至少有一个主线程。
进程在执行时拥有独立的内存单元，同一个进程中的不同线程共享进程被分配的空间。线程共享代码段，数据段，但每个线程
拥有独立的栈段和寄存器组。
一个进程挂掉，不会影响其他进程。一个线程挂掉，整个进程崩溃。进程切换需要的开销显著大于线程切换。

2 线程同步的方式：互斥锁，自旋锁，读写锁和条件变量
各个线程之间需要对共享资源实现有规律的访问，互相排斥的访问同一个资源，这就是各个线程的同步。

互斥锁和自旋锁的区别：C++中的mutex
互斥锁加锁失败后，线程会释放CPU，给其他线程，该线程从运行态变为阻塞态；
自旋锁加锁失败后，线程会忙等待，直到它拿到锁。
互斥锁加锁失败后会从用户态陷入内核态，操作系统帮我们切换线程，这样存在开销。两个线程属于一个进程，切换线程时，CPU
会记录私有数据和寄存器等不共享的数据，如果锁住的代码执行时间较短，上下文切换的时间比锁住的代码执行时间还长。这时使用
自旋锁较好。
自旋锁通过CPU提供的CAS函数，在用户态下完成加锁和解锁，如果加锁失败不会阻塞而是忙等待，直到它拿到锁。自旋锁一直自我旋转，直到
锁可用。

读写锁：C++中的shared_mutex
读写锁使用于能明确区分读写操作的场景。只读取共享资源的是读进程，要修改共享资源的是写进程。读多写少的场景适合读写锁。
读锁是共享锁，因为读进程不会修改共享资源，可以同时有多个进程读资源，而写锁是互斥锁或者自旋锁，因为写进程会改变资源。
对于写进程，使用lock和unlock操作；对于读进程，使用lock_shared和unlock_shared操作 
C++引入了新的函数配合读写锁：unique_lock针对写锁，shard_lock针对读锁。
缺点：如果一直有读线程获取读锁，写线程永远获取不到写锁，写线程饥饿，如果一直有写线程获取写锁，读线程也会饥饿。
公平读写锁：用队列把获取锁的线程排队，按照先进先出的原则加锁。

悲观锁和乐观锁：互斥锁，读写锁，自旋锁都是悲观锁，悲观锁认为操作共享资源时，如果不加锁，别的线程会修改资源；乐观锁
认为别人不会修改资源，所以不会上锁。

3 孤儿进程和僵尸进程
首先先介绍fork函数。头文件 #include <unistd.h>  函数签名pid_t fork(void);
windows中无法使用该函数，linux才可以。
父进程可以创建一个子进程，fork为这个进程分配新的进程空间。子进程是父进程的一个副本。
fork的返回值有三种：1）父进程返回值为创建的子进程的pid；2）子进程返回值为0；3）错误为-1。
fork函数特殊的地方在于调用一次返回两个值，在两个不同的进程中返回两个值，因为这两个进程共享代码段。

孤儿进程：父进程退出，子进程还在运行，就编程孤儿进程。孤儿进程将被init进程收养。
僵尸进程：子进程退出，但是父进程没有调用wait或waitpid系统调用取得子进程的终止状态，子进程的进程描述符任然在系统中，
占用系统资源，僵尸进程。

fork的底层：读时共享，写时复制：
fork后的子进程直接复制父进程的所有资源非常耗费资源。所以有读时共享，写时复制。两个进程的虚拟空间不同，但是映射的物理空间相同，
当只是读取资源时，直接读取物理空间，只有在需要进行修改时，才将其进行拷贝，并且映射到子进程的虚拟空间上。

4 死锁和避免
死锁：多个进程在执行任务中，因争夺资源造成的互相等待。
产生条件：
1）互斥条件：进程所分配得到的资源要互斥访问，该进程得到该资源，其他进程无法使用；
2）请求保持条件：进程要索取其它资源，并且不会释放自己的资源；
3）不可剥夺条件：进程已经获得的资源，只能自己释放，不可剥夺；
4）环路等待：若干进程的资源等待关系是环形的，即互相等待对方的资源

避免：
1）破坏请求保持：资源一次性分配完； 2）不可剥夺：进程的资源未满足时，释放已有的资源；
3）环路等待：资源有序分配，避免环路出现。

5 多线程和多进程
多个进程拥有各自独立的内存单元，切换时代价较大。同一个进程中的线程切换时代价较小，因为它们共享进程的大部分资源，
，比如代码段，数据段，但是线程有自己的栈段和寄存器组。 进程之间的通信方式也和线程之间不同。
多进程切换需要刷新TLB，即虚拟内存到物理内存的映射表。线程切换不需要，因为线程之间共享进程的虚拟内存。
多进程适应于多核、多机分布；多线程适用于多核。

6 进程通信和线程通信
进程通信：1）管道 2）系统IPC 3）套接字socket
进程之间内存地址不同，不能直接获得对方的信息。所以需要通信方式。
1）管道（缓冲区）：半双工方式，所以要互相通信必须建立两条管道，只有写满了才能读，只有读空了才能写。
缺点：只能在有亲缘关系的进程之间使用；值支持单向数据流；缓冲区有限。
匿名管道半双工，命名管道可以允许无亲缘关系进程间的通信。

2）系统IPC
共享内存：共享的一块内存空间，进程间可以互斥访问。
信号量：一个计数器，用于多进程对共享数据的访问，实现进程间的同步。
信号:Linux系统中用于进程间通信的一种机制。信号被某个进程产生，并设置信号传递的对象（另外一个进程），然后传递给操作系统，
操作系统将该信号给相应进程。比如子进程可以产生一个退出信号，告诉父进程自己已经结束，父进程可以回收PID，避免出现僵尸进程。
消息队列：内核中的消息链表。一直客观存在，允许多个进程同时读取或者写入信息。

3）Socket套接字
不同主机之间的通信。

消息队列在内核中存在，只有在内核重启时，一个消息队列才会被真正删除，而且可以支持同时写和读。但是它们都遵守先进先出原则。


7 进程和线程切换上下文的过程：
上下文切换是指内核（OS的核心）在CPU上对进程或线程进行切换
进程切换：
1）保护被中断进程的处理器现场 2）修改进程PCB的信息，比如进程状态（PCB一直在内存中） 3）把中断进程的PCB挂入有关队列
4）进程调度算法选择下一个进程 5）切换内核栈和硬件上下文（内存，数据段和代码段） 切换页表和TLB，使用新的地址空间
关于TLB。每个进程都有自己的虚拟地址空间，映射到实际的物理地址空间，需要一个页表，查找页表很慢，所以有一个cache就是TLB，
加速页表查询，每个进程都有自己的页表。进程切换，页表改变，cache就失效了。
6）根据被选中进程恢复处理器现场

线程切换：
基本差不多，只不过不需要切换页表和TLB，因为线程之间共用进程的虚拟内存

8 进程的调度算法
1）先来先服务：每次选择先到队列里的进程进行处理，对于短时间的作业不利
2）短作业优先：选择时间最短的进程进行处理，会导致饥饿
3）高优先级调度：把就绪队列中优先级最高的进程先处理，会导致饥饿
4）时间片轮转：进程执行够一个时间片就切换下一个进程
5）多级反馈队列调度算法：对上述算法的折中权衡。设置多级就绪队列，队列优先级从高到低，时间片由小到大。新的进程到达先进入第一层，
按照先来先服务原则分配时间片进行，时间片到后进入下一级队列队尾，只有第k级队列为空时，才会为k+1级队头的进程分配时间片。

9 阻塞IO与非阻塞IO


10 同步与异步的概念

11 静态链接和动态链接
程序编译链接四步：预编译，编译，汇编，链接
静态链接：
实际开发中，不可能把所有代码放在一个源文件中，所以会出现很多源文件，各个源文件之间是相互依赖的，每个源文件独立编译，每个.c文件
最后都会形成一个.o文件，需要将这些目标文件进行链接，形成一个可执行的程序。比如一些C++库函数，就会链接很多系统.o文件。
静态链接的优缺点：
浪费空间，每一个目标文件链接时都会多一份副本，并且更新比较困难，每次库函数的代码修改，已经编译链接的代码需要重新编译链接一次。
优点：可执行程序中已经具备了所有可执行程序需要的东西，执行速度快。

动态链接：把程序按照模块拆分为各个独立部分，在程序运行时才链接到一起。
比如program1.o和program2.o都需要一个库lib.o。在program1.o运行时发现需要lib.o，加载lib.o，如果此时program2.o也需要lib.o,
不需要重新加载,而是将lib.o映射到program2的内存空间中.
优点:没有很多副本,空间更少.更新方便. 缺点:把链接推迟到程序运行时,每次运行都要重新链接,性能会损失.

12 虚拟内存
内存：程序要放到内存中才能被CPU处理。
地址单元：内存按照字节进行编号。比如4GB的内存，2的30次方 * 4，所以需要32个二进制位才能标识地址。
操作系统对内存空间的管理：
1）内存空间的分配和回收 2）内存空间从扩充，包括虚拟内存技术 3）逻辑地址到物理地址的转换 4）内存保护，保证各个进程在自己的内存空间运行。

内存被划分为等大的若干个物理块（页框），将进程的地址空间分为和页框等大的区域，称为页面。每个页面都有编号，即页号。
逻辑地址到物理地址的转换：物理地址 = 页面始址 + 页内偏移量 
页面始址：逻辑地址对应的页号，就是这个是第几页 页内偏移量：逻辑地址在页面内的偏移量（在同一个页面内的地址是连续的）
页表：进程的每个页面在内存中存放的位置的表
快表：TLB，访问速度比内存快很多的高速缓冲寄存器。如果快表命中就不用访问内存了，存放的是内存中页表的一部分副本内容。

正常的作业运行，把作业整个装入内存中开始运行。这样会导致作业如果较大，无法被全部装入内存；如果作业被滞留在内存中，直到结束才释放
，其它进程可能就没有内存可以运行，长期处于等待。
总而言之：许多在程序运行时暂时不用的数据占据了大量的内存空间，但是一些需要运行的程序又无法装入。

虚拟内存技术建立在局部性原理上：1）时间局部性：程序中某条指令执行后，很快就会再次执行；某个数据被访问后，很快就会再次访问；
2）空间局部性：某个存储单元被访问，其附近的存储单元也会被访问。
物理内存有四个层次：寄存器，高速缓存，主存，磁盘。速度越来越慢，空间越来越大。

程序装入时，不必把所有程序都装入内存，将一部分装入内存，其余留在外存，如果需要信息，再从外存换入内存，将暂时用不了的东西放回外存。
系统这样好像是提供了一个比实际内存大很多的存储器。操作系统会为每一个进程分配一个独立的地址空间，进程有自己的虚拟内存，页表记录了进程
中虚拟内存到物理内存的映射。

13 MMU地址翻译的具体流程
Memory Management Unit 内存管理单元
引入快表机制后，基本分页管理的过程 地址翻译就是将逻辑地址翻译成内存中实际的物理地址。
1）首先，通过逻辑地址计算出页号和页内偏移量；2）检查页号是否越界 3）查询快表，看该页表项是否已经存在，如果存在，直接得到该页号的起始地址，即对应的物理块
4）如果快表未命中，查询内存中的页表即慢表，得到起始地址 5）起始地址 + 页内偏移量 = 物理地址

请求分页管理的过程
查快表（未命中）----> 查页表（发现未调入内存）-----> 分页中断，将页面从外存换入内存，并加入快表 ----> 查快表

14 缺页处理过程
内存有限，所以可以将进程中还没有用到部分存储在外存，需要时才调入内存。
页表的修改：加入状态位：该页面是否在内存 访问字段：该页面被访问过几次，用于置换算法 修改位：页面调入时是否被修改 外存地址

缺页中断：内中断，和当前执行的指令有关，如果请求分页系统中，要访问的页面不在内存中，就会产生缺页中断，将该进程阻塞，由操作系统的缺页中断程序处理中断，
将外存中的内存块换入内存，如果没有空闲的内存块，页面置换算法选择一个内存中的页面淘汰。

15 缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法
程序执行时，访问的信息不在内存中时，由操作系统将所需信息从外存调入内存，如果内存不够，就必须将内存中暂时用不到的信息换出到外存。页面置换算法就是决定应该换出
哪个页面。页面的换入换出需要磁盘I/O，开销较大，所以算法应该追求更少的缺页率，即让换入换出的次数尽量少。
1）最佳置换算法：每次换出的都是以后用不使用或者最长时间不再被使用的页面，但是这执行的情况是无法预料的，所以这是无法实现的
2）先进先出算法：每次换出的都是最早进入内存的页面
3）最近最久未使用置换算法（LRU）：每次换出的都是最久未使用的页面，双向链表+哈希表
4）时钟置换算法（最近未用算法）：每个页面有一个访问位，把内存中的页面链接成一个循环队列。一开始全是0，表示最近没访问过，将第一个为0的页面换出。之后每次访问页面，
就将该页面的访问位置为1，接着找最近的0去换出。
改进时钟置换：如果一个页面没有被修改过，是不需要执行I/O操作写回外存的。所以不仅可以考虑该页面是否被访问过，还可以考虑页面是否被修改过。

16 中断：唯一从用户态切换到核心态的方法
1）中断发生，CPU立即进入核心态 2）当前的进程暂停运行，操作系统内核对中断进行处理 3）不同的中断信号，会进行不同处理
内中断：和当前执行的指令相关 外中断：与当前指令无关，比如外设请求 （I/O设备发出指令），人工干预（ctrl + c）
