STL底层数据结构
vector：array是静态数组，初始化之后就无法改变大小。可以动态扩容的vector。
vector维护一个连续线性空间，三个主要的迭代器，start，finish和end_of_storage目前使用的头，尾和实际的尾
加入新元素如果超过当前容量，capacity直接x2。

list 双向链表
每个节点node有三个数据，当前节点的数值，指向前节点的指针，指向后节点的指针。

deque
可以实现数据前后的插入，deque容器存储数据的空间是一段一段等长的连续空间，各段空间之间不一定是连续的。
用map数组存储着各段连续空间的首地址。需要在头部或者尾部增加存储空间时，开一段新的空间，并在map数组的开头或者
结尾添加指针。
为了判断当前元素是否处于空间边缘位置。deque内部有4个指针。cur：当前遍历的元素 first该层首地址 last该层尾地址 node：二级指针，指向map数组中当前层的指针

stack和queue底层都是deque实现的，只是关闭了一些接口。

priority queue背后用heap实现 heap分为最大二叉堆和最小二叉堆 用一个vector模拟heap（完全二叉树），每个根节点的元素比子节点大。
每次push新元素时，实现上溯，将新元素先放到数组尾部，再与父节点逐个比较，如果大于父节点就交换。
每次pop顶部元素时，实现下溯，将顶部元素与尾部元素交换，删除尾部元素，再将顶部元素逐个与子节点比较。

set map multiset multimap 底层是红黑树
unordered_set unordered_map 底层是哈希表

红黑树：一种平衡二叉搜索树，只不过是弱平衡的。叶节点和根节点都是黑色的，每个节点非红即黑，每个红色节点的两个根节点都是黑色节点，保证一个节点到其子孙节点的所有路径上包含相同数目的黑色节点。
上述的这些条件保证所有一条从根节点到叶子节点的路径，最长的不可能比最短的长两倍。

哈希表：实现o1的时间复杂度查找数据，设计一个哈希函数，确保通过key值和哈希函数可以得到存储地址。所以如何设计哈希函数是非常重要的。
哈希冲突：不同的key根据哈希函数映射得到的数值相等。
1）链表法：有冲突的数据放到一个链表里，根据key查到链表的首地址，然后遍历找到数值；

手写哈希map：

关于树

二叉搜索树：
两个条件：
1）左子树所有节点的值都小于当前节点，右子树所有节点的值都大于当前节点
2）左右子树都是二叉搜索树
特点：中序遍历是有序的数组；查找和插入的的时间复杂度与二分查找一样，但是也可能有退化的情况，因为极端情况，BST可能会退化成链表

平衡二叉树
二叉搜索树可能会出现退化成链表的情况。平衡二叉树就是很均衡的一种树。左右两个子树的高度差绝对值相差不过1.

AVL树 平衡二叉搜索树
这个就解决了二叉搜索树会出现的链表退化问题。把查找，插入，删除的时间都控制在了O(logn)。但是为了保持平衡，会频繁旋转，这会牺牲时间。
如果是左左或者右右的情况。即根节点左节点冗余，冗余的左节点的左节点也冗余，这只需要一次旋转即可。
如果是左右或者右左的情况，需要两次旋转，第一次先变成左左或右右，第二次再旋转一次

红黑树 也是一种平衡二叉搜索树
AVL树虽然避免了普通平衡二叉树的退化情况，但是不断的重构是我们不想看到的，这就出现了红黑树。map和set都是用红黑树实现的。
红黑树其实是一种弱平衡二叉搜索树，性质如下：
1）节点是红色或者黑色的 2）根节点是黑色 3）所有叶子都是黑色的 4）每个红色节点必须有两个黑色子节点
5）从任一节点到每个叶子的所有路径都含有相同数目的黑色节点。
这些约束确保了红黑树的弱平衡性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
红黑树插入最多两次旋转，删除最多三次旋转，是一种折中的处理。红黑树的旋转分为左旋和右旋，改变节点颜色和指针结构来保持红黑性质

B（balance）树：包括B-树，B+树，B*树
B树也是一种用于查找的平衡树，但是是多路平衡查找树，允许每个节点有更多子节点。
B-树主要用于外部存储器设计的，比如磁盘，它适用于读取和写入大块数据，被用于文件系统及数据库中。
why有B树。虽然之前用来搜索的二叉树很多，但是数据大的时候就无能为力了，数据量大时，内存不够用，大部分数据要放在磁盘中，但是如果用
常规的平衡树，会造成磁盘I/O时间较多，从磁盘读取数据是非常费时的。
B-树将每个节点的区间设置的较大，每个节点就是一页，每次磁盘I/O读取一个节点。由于层次比较多，所以比二叉树搜索的快。

B+树与B-树不同，B-树key-value存储在一起，B+树的话，只有最后一排有value，但是所有叶子节点都增加了链指针指向下一个元素。
这导致B-树查询时间最快只有o(1)，B+树稳定的log。B+树很好的利用了空间局部性原理，即某个内存被访问了，其附近的位置也可能被访问到。
B+树更适合外部存储，因为不需要data域，每个节点能索引的范围更大了。B+树很好的利用了局部性原理，提前把已经访问过的key的data读入内存，就可以减少I/O次数，也可以完成范围查找。
所以MySQL也是用的B树作为索引结构。索引本身很大，不可能全部存储在内存中，磁盘I/O存取的消耗是很大的，使用B树可以减少磁盘I/O次数。

C++基础
1 面向对象的三大特性：封装，继承和多态
首先，简述一下面向对象的思想。把一切东西抽象成一个个对象，把一类对象拥有的属性和操作打包封装成一个类来表示。
C语音是面向过程进行编程，根据任务的逻辑从上到下写代码。C++则是OOP面向对象编程，将数据和函数绑定到一起，进行
封装，可以更快速方便的开发程序，便于维护，减少了重复代码的开销。

三大特性:
1) 封装：封装的本质是一种管理。将一个类封装起来，不想给外部看到的，用private/protected封装起来，开放一些
public的成员给外部。将数据和操作数据的方法结合起来，隐藏了对象的属性和实现方法，对外部仅公开一些接口。

2）继承：子类（派生类）可以继承父类的功能，无需重新编写。
https://www.runoob.com/cplusplus/cpp-inheritance.html
关于访问控制权限：同一个类中，可以访问public，protected和private对象；对于外部的成员，只能访问public；对于
派生类，可以访问public和protected。
派生类继承了所有的基类方法，但是有三种情况除外：
1）基类的构造函数和析构函数，所以不能直接在派生类中调用基类的构造函数进行赋值，可以使用初始化列表。
2）基类的重载运算符 3）基类的友元函数

继承类型：
派生类有三种继承方式，public，protected和private。默认的是private，通常使用public，即从基类继承的方法和成员
在派生类中的控制权限。
public继承：public -> public, protected -> protected;
protected继承：public -> protected, protected -> protected;
private继承：public -> private, protected -> private;
派生类不能访问基类的private，继承只能提高权限，不能降低权限。

3）多态：多种形态，当类之间存在层次关系，即继承关系时，就会用到多态。可以在基类和派生类中同一个名称的函数但是又不同
的实现。在基类中使用virtual修饰的函数是虚函数，在派生类中可以对其重新实现（重写）。当用基类指针指向派生类时，编译器使用动态
绑定，不看指针的类型而是看指针具体的内容。

向上隐式转换是被允许的，即派生类引用或者指针转换为基类引用或指针。基类拥有的方法派生类都是拥有的。
向下隐式转换是危险的，即基类引用或指针转换为派生类引用或指针。派生类的有些方法是基类没有的。

为什么基类的析构函数应该是virtual。保证正确的析构顺序。构造顺序，先基类再派生；析构顺序，先派生后基类。构造函数不能是虚函数，如果构造函数是虚函数
，那构造的时候就是先构造派生类，但是这时还没有构造基类，所以不能成功。

虚函数和纯虚函数的区别：
虚函数不代表该函数没有被实现，只是表面子类可以重新实现它并允许用基类的指针来或引用来调用子类的这个函数。
定义一个纯虚函数才代表该函数没有实现，只是一个接口，起到一个规范作用，规范子类必须实现该函数。
virtual void funtion1() = 0；在函数后面=0即为纯虚函数。

虚函数的工作原理：每个类都有一个虚函数表，保存了虚函数和其地址。派生类如果没有重新实现虚函数，地址不变，
如果重新实现了就添加为新的地址，如果有新的虚函数，也添加到末尾。
所以，虚函数会增加内存和运行成本，主要就是因为要构造虚函数地址表，调用函数时也需要去表中查找相应地址。

2 类的构造函数，析构函数，赋值函数，拷贝函数

3 移动构造函数和拷贝构造函数区别
构造函数都是在创建对象时使用，赋值函数则是该对象已经存在，对该对象赋值时使用。
拷贝构造函数是用同一类已有的对象来创建对象。如果没有拷贝构造函数，编译器会自行定义一个。但是如果类中有
指针变量并且动态分配内存，那么必须自定义一个拷贝构造函数，否则就会有浅拷贝问题。

浅拷贝和深拷贝：默认的拷贝构造函数只会简单的对值进行复制，这样会导致构造的新的对象的指针和原始对象的指针指向相同的内存。
这样如果一个对象调用析构函数进行析构，那么另一个对象再指向这部分内存时就会越界，出现悬挂指针的现象，而对同一个块内存执行
两次以上释放的结果是未定的，会导致内存泄漏或程序崩溃。

C++11之后引入了移动构造函数和移动赋值函数。拷贝构造函数对对象的所有数据成员都进行了一次拷贝，即深拷贝，这样是有开销的。有时
传入的对象是右值，即用完就没用的，这时没必要全都复制一遍，只要将传入的对象的内存地址空间接管即可。再将传入的类的指针置为nullptr。
移动构造函数传入的是右值，将临时对象拥有的内存移为己用，省去了复制的过程。

4 空类有哪些函数，空类的大小。
空类有构造函数，析构函数，拷贝构造函数，拷贝赋值函数，移动构造函数，移动赋值函数，取地址运算符&；空类实例化会占一个字节，为了让对象的实例可以相互区别。

5 内存分区：全局区，堆区，栈区，常量区，代码区
从低地址到高地址，分别是代码段（二进制机器指令，一些只读的常量），数据段（data区存储已初始化的全局变量，bss区存储未初始化的全局变量），
堆段（动态申请，低地址向高地址生长），共享区，栈区（局部变量，从高地址向低地址生长，连续内存空间）。

6 C++和C的区别
1）C语言是C++的子集，C++可以很好的兼容C语言。C++有自己的新特性，如引用，智能指针和auto变量等；
2）C++是面向对象。C面向过程；
3）C++复用性高，引入了模板编程的概念，函数模板和类模板。C++还引入了STL库。
4）C语言有一些不安全的地方。指针的使用有潜在危险，容易造成内存泄漏，C++引入了智能指针。隐式转换不安全，
如int转换为long，向上隐式转换一般是安全的，但是long转换为int这种向下隐式转换容易造成数据溢出。

7 struct和class区别
1）struct一般用于一个数据集合，里面是没有方法的，class则是一个对象的封装，包括数据和方法；
2）控制权限和继承权限：struct默认的控制和继承权限是public，class是private；
3）class关键字可用于定义模板参数，代替typename。

8 struct字节对齐
结构体中的不同数据占的字节是不同的，以32位OS为例，int 4字节，char 1字节， short 2字节。
1）按照各个成员的字节数的最小公倍数来对齐，补全每个数据；
2）超过操作系统基本字节单位，按照基本字节对齐。
字节对齐的原因是：
如果没有字节对齐，浪费时间在读取数据上，以空间换取时间，加速读取数据。
手动设置字节对齐：服务器进行网络通信时，公用一个结构体，需要手动设置对齐规则，确保两边结构体长度一致。
#pragma pack(n)//表示它后面的代码都按照n个字节对齐
#pragma pack(pop)//取消按照n个字节对齐，是对#pragma pack(n)的一个反向操作

9 new/delete和malloc/free的区别
首先，这两组操作一定要配套使用。前者是C++的运算符，后者是库函数。
对于非内部数据类型，比如结构体和类。malloc是不够的，它只能分配内存空间，但是new还会调用构造函数，由于malloc
是系统的库函数，不可能把构造函数的功能强加上去，所以需要new。
new分配内存时不需要指定内存块大小，编译器会计算。malloc需要显示的指出内存大小。int *p = new int[n]; int *p=(int *)malloc(n * sizeof(int));
返回类型：new分配成功直接返回对象类型的指针，不需要转换类型，是安全的操作符；malloc成功则返回void*，需要强制类型转换。
分配失败，new抛出bad_alloc异常，malloc返回空指针。
new在使用时 1）先调用operator new函数，申请足够内存（通常还是由malloc实现）;2）调用构造函数。
delete时   1）先调用析构函数，2）再调用operator delete函数释放内存（通常还是用free实现）
new在free store（自由存储区）上分配内存，malloc在heap上分配内存。

10 内存泄漏的情况
申请了一块内存空间，使用完毕后没有释放掉，就是内存泄漏。
1）new和malloc后，没有及时delete和free 2）基类派生时，析构函数不使用虚函数。
3）windows句柄资源使用后没有回收：在Windows开发中，当调用Windows API，比如CreateFile, CreateEvent, CreateThread 等API的时候，都会返回一个句柄Handle。当相应的资源使用完后，如果没有调用CloseHandle去关闭Handle，则会出现句柄泄露的问题。
检测内存泄漏：
1）记住及时用相应的函数释放内存；2）使用智能指针；3）使用一些工具插件ccmalloc、Dmalloc、Leaky、Valgrind。

11 sizeof和strlen的区别
sizeof是运算符，strlen是函数。前者返回的是内存空间大小，后者是char*的长度，且必须是以\0结尾的。
注意，char str[] = "abcd" sizeof返回的是空间大小，为5字节，因为后面有一个\0。strlen是4，是实际的长度。

12 指针与引用的区别
1）引用的初始化必须指向已有的有效的变量，指针初始化可以为空指针；
2）引用一旦被定义，就不能更改指向的对象，指针可以重新指向新的对象；
3）引用是一个对象的别名，指针本质是一个变量，只不过该变量的内容是指向对象的地址；
4）指针可以有二级指针，引用只有一级的；
5）指针++指的是下一个指针，引用++是指对象++；sizeof一个引用得到的是对象的大小，sizeof一个指针是指针本身的大小。

函数的三种传参方式：值传递，引用传递，地址传递。
1）值传递：把对象拷贝一份，传递到函数中，在函数中操作的对象是原始对象的副本，不会对原始对象有影响；
2）引用传递：不会为形参分配新的内存空间，形参只是实参的别名。
3）地址传递：形参是指针，将实参的地址传递给函数，在函数中可以改变实参的值，函数结束后释放指针变量。

13 野指针和悬空指针的产生和避免
1）野指针：指针指向不确定的地方，初始化时没有置为nullptr的指针，在初始化时赋值或者置空。
2）悬空指针：指针指向的内存空间已经被释放，在指针指向的空间释放后将指针置空，或使用智能指针。

14 静态多态和动态多态
多态就是多种形态。包括虚函数，模板编程和重载，从绑定时间进行分类可以分成静态多态和动态多态。
静态多态：在编译器期间实现的多态是静态多态；动态多态：在运行期间实现的多态是动态多态。
静态多态：模板编程和泛型编程，比如STL库，不给出具体的数据类型，在编译时通过实参类型确定类型，或者是函数重载，在编译时才确定使用哪个函数。
动态多态：虚函数实现的动态多态，只有在运行时才知道是调用的是基类还是子类的函数。
静态多态在编译期间完成，效率高，编译器可以优化，但是模板容易导致调试困难，编译耗时，代码膨胀等问题。
动态多态在运行期间完成，处理同一继承体下不同对象的问题有优势，但是虚函数表会造成一定的开销。

15 一些关键字：static，const，extern，volatile
static:主要起到隐藏的作用。
对于全局变量，static修饰之后在同文件下的其它cpp就不能使用该变量，只能在该cpp中使用；
对于局部变量，static修饰之后，从局部变量变成全局变量，生存周期发生改变，但是作用域不变，代码块结束后不会被回收。
对于类中的static变量，它不属于具体的对象所有，而是类的所有对象共享的变量，访问时直接用类名进行访问即可。classname::function;不能在类中对static变量进行初始化，
只能在类声明外对其进行初始化。
对于类中的static函数，和static变量相同，也不是对象所有，所以没有this指针，只能调用类中的static变量，其它静态成员函数和类外部的函数。

const:常量
对于变量: 被定义为常量，不能对其进行修改。
对于指针：
1）（pointer to const 指向常量的指针 int a = 8; const int* p = &a）修饰指针指向的内容，则内容是常量；
2）（指针常量 int a = 8; int* const p = &a）本质是指针，只不过该指针是个常量。
const修饰函数：
修饰函数参数；参数是指针时，可以设置为指针常量，防止指针被篡改；参数是引用时，const引用防止对象被篡改；
修饰返回值：返回一个const类型。
const修饰类成员函数：
不会改变调用对象的值，就要声明为const成员函数，在函数签名尾部加上const。const这时不能与static函数一起使用，
static没有this指针，不会改变对象的值。

extern：修饰变量或函数，标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它文件中寻找。
特殊作用：extern "C"告诉编译器要按照C的股则去翻译该函数。
修饰变量：想要在本cpp中使用另一个cpp中的非static全局变量，需要加入extern表示该变量在别处定义了。
注意，正常数组的指针可以混淆使用，但是在外部声明时不行。

volatile：避免编译器指令优化
volatile修饰的变量可以让编译器不对其进行代码优化。volatile表示该值是容易变化的，告诉编译器每次都要老实
去内存中去得到该变量。当多线程并发访问共享变量时，该变量设置为volatile。

16 四种类型转换
static_cast、dynamic_cast、const_cast、reinterpret_cast
static_cast：静态转换，在编译器阶段就会判断是否安全，最基础的转换。基本都是良性转换，转换后风险较低，向上转换，比如int转long，派生类转基类，const转非const
const_cast：const转非const
reinterpret_cast：重新解释，非常暴力，一些static_cast不能转换的，比如int和指针之间的转换。
dynamic_cast：动态转换，在运行期间判断是否安全，类的继承层次之间进行类型转换。可以向上转换，向下转换需要在运行期间进行判断。
dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。

17 右值引用 move函数
可以取地址的是左值，不能取地址的是右值。
move本身不具备移动作用，它的功能就是把某个左值强制转化为右值。配合移动语义使用，比如移动构造函数。

18 四种智能指针及底层实现：auto_ptr、unique_ptr、shared_ptr、weak_ptr
智能指针的作用就是管理堆对象，避免内存泄漏的情况，即申请了空间在结束时忘记释放。智能指针就是一个类，当超出了类的作用域，调用析构函数，自动释放资源。
auto_ptr：已经不用了，两个指针指向同一块内存，释放两次。而且使用auto_ptr进行复制语义时，比如把sp1拷贝复制或者赋值复制给sp2时，sp1会变空，sp2会指向
之前的空间。
unique_ptr：两个sp同时指向同一块内存时，编译报错。静止复制语义使用，将拷贝构造函数和拷贝赋值函数全变成delete。
shared_ptr：可以多个指针指向同一个内存，有一个计数器count，如果count为0则释放资源。
shared_ptr中的循环引用怎么解决：一个资源的生命周期可以交给一个sp来管理，但是该sp的生命周期不能再交给该资源来管理。
定义一个类A，A中有智能指针成员，在主函数中创建一个指向A对象的智能指针，然后让A中的智能指针成员指向它本身this指针。这样就会出现循环引用。
出了作用域，准备释放资源，但是这时候指向A的shared_ptr有两个，不能释放A的资源，必须要销毁A才能销毁智能指针成员变量，但是必须销毁智能指针成员变量
才能销毁A。
weak_ptr：不控制对象生命周期的sp，指向一个shared_ptr的对象。是一个弱引用，它的构造和析构不会引起计数的增加或减少。

19 vector和deque是序列式容器 迭代器失效的情况
对容器的操作影响了元素的存放位置，称为迭代器失效
erase或者insert之后，操作位置到容器尾部的所有迭代器全部失效
erase和insert的返回值就是下一个有效的指针，如果还是按顺序返回的话，删除或者插入的迭代器会失效，失效的迭代器不能自加自减

list这样的链表式容器
删除和插入结点不会影响其它结点。

map, set, multimap, multiset关联式容器
删除节点只会对当前造成当前节点失效，对后面节点没有影响，所以在失效前将迭代器++就能指向下一个元素。

20 STL容器空间配置器
STL由算法 容器 迭代器组成。细分的话有6部分
空间配置器主要负责对象的创建与销毁，内存的获取和释放。由于new和delete都是分成两部分，所以空间配置和对象构造也是分开的。
内存空间配置和释放 对象构造和释放
内存空间的配置和释放使用两级配置器。一级配置器考虑大块内存空间，利用malloc和free实现。二级配置器考虑小内存，即内存碎片，采用链表
来维护内存池，空闲的内存块互相连接在一块，内存块一旦被使用，从链表中剔除。
https://blog.csdn.net/weixin_39640298/article/details/88766223

is a 和 has a的区别
is a是一种包含关系，比如水果类中有水果重量和价格的函数，苹果是一种水果，它可以继承水果类的重量和价格函数。但是有一个午餐类，午餐包含水果，但是午餐不只是
水果，这就是has a的关系。
实现has a有两种简单方法：
1）然一个类是另一个类的成员； 2）使用私有继承，父类的所有对象和函数都变成了private，新类的对象无法使用父类的接口。
