头文件

1.0 头文件应该自给自足
头文件本身依赖的其它头文件需要全部包含

1.1 #define保护
所有头文件都要有#define保护来防止头文件被多重包含
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_

1.2 前置声明
尽可能避免使用前置声明，优先使用#include

1.3 内联函数
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
内联函数编译器会将其直接展开，不会用函数调用机制，内联函数代码量少时，高效，
因为少了查找函数地址的时间，但是代码量多时，代码量增加。

1.4 include路径顺序
include顺序如下：
插入空行以分割相关头文件
1 相关头文件
2 C系统文件
3 C++系统文件
4 其它库的.h文件
5 本项目内的.文件

作用域

2.1 命名空间
命名空间将全局作用域细分为独立的，具名的作用域。可以防止全局作用域的命名冲突
不要在命名空间std内声明任何东西
不应该使用using指示引入整个命名空间的标识符号
// 禁止 —— 污染命名空间
using namespace foo;
禁止使用内联命名空间

2.2. 匿名命名空间和静态变量
在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。

2.3. 非成员函数、静态成员函数和全局函数
不要用类的静态方法模拟出命名空间的效果，类的静态方法应该和类的实例和静态数据紧密相关
namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject
上述是错误例子，用两个static函数模拟了命名空间的效果
namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject
正确的用法如上

2.4 局部变量
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);

vector<int> v = {1, 2}; // 好——v 一开始就初始化很好

2.5 静态和全局变量
只有POD变量才能定义static
POD(Plain Old Data)原生数组类型，比如int char float
