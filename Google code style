头文件

1.0 头文件应该自给自足
头文件本身依赖的其它头文件需要全部包含

1.1 #define保护
所有头文件都要有#define保护来防止头文件被多重包含
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_

1.2 前置声明
尽可能避免使用前置声明，优先使用#include

1.3 内联函数
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
内联函数编译器会将其直接展开，不会用函数调用机制，内联函数代码量少时，高效，
因为少了查找函数地址的时间，但是代码量多时，代码量增加。

1.4 include路径顺序
include顺序如下：
插入空行以分割相关头文件
1 相关头文件
2 C系统文件
3 C++系统文件
4 其它库的.h文件
5 本项目内的.文件

作用域

2.1 命名空间
命名空间将全局作用域细分为独立的，具名的作用域。可以防止全局作用域的命名冲突
不要在命名空间std内声明任何东西
不应该使用using指示引入整个命名空间的标识符号
// 禁止 —— 污染命名空间
using namespace foo;
禁止使用内联命名空间

2.2. 匿名命名空间和静态变量
在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。

2.3. 非成员函数、静态成员函数和全局函数
不要用类的静态方法模拟出命名空间的效果，类的静态方法应该和类的实例和静态数据紧密相关
namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject
上述是错误例子，用两个static函数模拟了命名空间的效果
namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject
正确的用法如上

2.4 局部变量
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);

vector<int> v = {1, 2}; // 好——v 一开始就初始化很好

2.5 静态和全局变量
只有POD变量才能定义static
POD(Plain Old Data)原生数组类型，比如int char float

类

3.1. 构造函数的职责
构造函数不得使用虚函数

3.2. 隐式类型转换
不要定义隐式类型转换，对于单参数构造函数，使用explicit修饰；
explicit只能修饰单参数的构造函数 C++中单参数的构造函数可以隐式进行转换
比如定义Test类 构造函数 Test(int n){num = n}; 直接写Test A = 1；这是可以的
但是这样的写法违背我们的本意，所以要加上explicit限制

3.3 可拷贝类型和可移动类型
如果需要拷贝/移动构造，就定义，把对应的赋值函数也要定义。如果不需要，禁用默认的拷贝和移动函数。

3.4 结构体 VS. 类
当只有数据成员时使用struct，其它时候使用class

3.5 继承
请使用public继承。对于重载的虚函数，使用override显示表明该函数被重写了，否则还会去基类查看该函数是否为虚函数

3.6 多重继承
一般很少见，除非只有一个父类是非抽象类，其余都是纯接口类。
抽象类（纯接口类）：至少有一个函数被声明成纯虚函数

3.7 接口
接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).

3.8 运算符重载
除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.

3.9. 存取控制
将所有数据成员声明为private, 除非是static const类型成员(遵循常量命名规则). 

3.10 声明顺序
将相似的声明放在一起, 将 public 部分放在最前.类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分.

函数

4.1 输入输出
我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空

4.2. 编写简短函数
我们倾向于编写简短, 凝练的函数.

4.3. 引用参数
所有按引用传递的参数必须加上 const.

4.4 函数重载
若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.

4.5 缺省参数
虚函数不能使用缺省参数，因为虚函数的要求函数签名必须相同，一旦参数不同，虚函数就可能会报错。
一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.

4.6. 函数返回类型后置语法
只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.
后置语法：
int foo(int x); 可以写为 auto foo(int x) -> int;

来自google的奇技

5.1 所有权和智能指针
动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.
unique_ptr指向的内存最好保持在分配者手中，不要进行拷贝，它的拷贝函数是被禁用的

5.2 Cpplint
使用 cpplint.py 检查风格错误.

C++其它特性

6.1 引用参数
所有按引用传递的参数必须加上 const

6.2 右值引用
只在定义移动构造函数与移动赋值操作时使用右值引用. 
对于unique_ptr，只接受移动语义，move是必须的
不要使用forward语义

6.3 变长数组和 alloca()
我们不允许使用变长数组和 alloca().
变长数组和alloca()不是标准C++组成部分。它们根据数据大小动态分配堆栈空间，会引起难以发现的内存越界bug
使用更安全的vector和unique_ptr<T[]>

6.4 友元函数
允许合理的使用友元类及友元函数。

6.5 异常
不使用 C++ 异常。
对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦

6.6 类型转换
使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;

6.7 流
只在记录日志时使用流.

6.8 前置自增和自减
对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.

6.9 const用法
我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。

6.10 constexpr用法
在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。
变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变.

6.11 整型
如果不确定具体的大小，就使用<stdint.h>中长度精确的整型 int_16t int_64t
C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位

6.12 64 位下的可移植性
代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记

6.13 预处理宏
使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之
宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域

6.14 nullptr和NULL
整数用0 实数用0.0 指针用nullptr 字符串用'\0'
C++中是直接把NULL宏定义为0 #define NULL 0 所以如果函数重载时有两个函数，一个形参是指针，一个是int
，那么参数是NULL就会出现二义性，到底我输入的int还是指针

6.15 sizeof
尽量使用sizeof（varname）而不是sizeof(type)
如果结构体中的类型改变，大小可能会改变，用type的话容易出错

6.16 auto
用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方

6.17 列表初始化
任何对象类型都有科被列表初始化。自定义类型也可以定义接收std::initializer_list<T>
的构造函数和赋值运算符，来实现列表初始化
不要直接列表初始化auto变量，很难理解
auto d = {1.23}  d可能是一个数组，也可能是一个double

6.18 lambda表达式
适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来
[](){}; 在方括号中是捕获变量[=]默认捕获 [&]按引用捕获 包括this [this]函数体内可以使用Lambda所在类中的成员变量
1）引用捕获陷进 捕获了局部变量，局部变量释放后，引用就不知道指向什么地方了
2）捕获this指针：如果lambda函数里有比this指针声明周去更长的变量，那么this指针失效之后再使用该函数就出错了

6.19 模板编程
不要使用复杂的模板编程

6.20 Boost库
只使用 Boost 中被认可的库

6.21 C++11
适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性




