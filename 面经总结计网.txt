1 OSI七层参考模型
应用层，表示层，会话层，运输层，网络层，数据链路层，物理层。

2 TCP/IP五层参考模型
应用层，运输层，网络层，数据链路层，物理层。
每一层可以使用下一层的服务，同时为上一层提供服务。

应用层：
1，DNS域名系统
我们实际访问的不是IP地址，而是域名。DNS域名系统就是将域名转换成IP地址的系统。包括，本地域名服务器，根域名服务器，顶级和权限域名
服务器。可以采取递归和迭代两种方法进行查询。主机首先向本地域名服务器查询。

DNS域名系统既使用UDP又使用TCP。
大部分时候使用UDP，只有在以下两中情况使用TCP连接。
1）超过512字节的DNS响应报文；或者当UDP传输超了字节时使用TCP
2）区域传输时使用TCP。域名服务器分为主从两种，主服务器主要写，从服务器负责读，主从服务器实现数据同步时使用TCP。

2 FTP协议（了解）
文件传输协议，向公众提供文件拷贝服务，不要求事先登记注册，即可以匿名操作。使用TCP可靠连接。
FTP协议监听两个端口20，21。控制进程监听21端口，信息传输进程监听20端口。
控制连接：服务器端打开TCP21端口监听，客户端发送连接。
数据连接：1）主动方式：客户端发送连接请求，服务器通过TCP端口号20主动建立连接；
2）被动连接：客户端发送PASV命令，告诉服务器进入被动模式。服务器旋转临时端口，客户端主动与服务器段建立连接。
有两种传输模式，文本传输和二进制序列传输。

3 关于HTTP协议
HTTP协议大多数情况下都是文本形式的明文格式，所以是text文本的协议。
由包头（1-7行）和包体（7行以后）组成。
请求报文：
GET/POST URL路径 HTTP版本协议号 \r\n
Host：。。。。\r\n （请求的主机名）
Connection：。。。\r\n （连接方式）
User-Agent：。。。\r\n（产生请求的浏览器类型）
Accept：。。。\r\n （客户端可识别的内容类型列表）
\r\n

包头和包体由\r\n区分开

响应报文：用状态码代替URL，其余相同。

GET，POST, PUT, DELETE （查，增，改，删）
GET：请求服务器上的资源，不对其进行修改。安全和幂等的。
POST: 向服务器提交数据，修改资源。比如评论某个新闻。增加的资源存放位置由服务器决定。
PUT: 向服务器提交数据，但是增加的资源存放位置指定了。
DELETE：删除某一资源。
HEAD: 不含有呈现数据，仅仅判断该资源是否存在。

HTTP1.1 比 HTTP1.0提高：
1）1.1引入了更多的缓存处理； 2）1.1优化了带宽和网络连接：
3）错误通知：1.1新增了24个错误状态相应码；
4）host头处理：1.0中默认一个主机只有一个IP，但是虚拟主机技术出现，导致一个物理服务器可以有多个虚拟主机，
它们共享一个IP，如果没有host主域，会报错。
5）长连接：1.1支持长连接和流水线处理，在一个TCP上可以传送多个HTTP请求和响应，keep-alive。

HTTPs 和 HTTP的区别
HTTPs在HTTP的基础上加入了SSL/TLS进行加密和解密。且HTTPS端口号是80，HTTP是40。
HTTPs加密流程 https://segmentfault.com/a/1190000021494676

cookie和session的区别
HTTP协议本身是无状态的。Cookie是存储在浏览器上的一小段文本信息，记录用户之前的浏览记录。浏览器再次请求该网站时，
浏览器会把cookie也发给服务器。服务器检查到cookie，判断用户状态，推荐用户感兴趣的信息。
session也是一种记录用户状态的机制，但是session存储在服务器上。更加安全，而且存储容量更大。

HTTP2.0的提高
1）新的二进制格式：1的版本是基于文本，文本协议表现形式很多，不够健壮。2.0采用二进制格式，更健壮。
2）多路复用：2.0的连接可以同时发起多重的请求-响应消息，连接共享。每个request有自己的id，一个连接上可以
有多个request同时多路复用，减少了TCP建立连接的开销。
3）header压缩：1版本的header带有大量信息，每次都要重复发送。2.0对header数据进行压缩，通讯双方各自缓存
一份header fields表，差量更新HTTP头部，避免了header的重复传输，减少了需要传输的大小。
4）服务端推送：在客户端请求之前就发送数据。服务端在发送HTML页面时就主动推送其他资源，将这些资源存到客户端本地。

4 运输层 TCP和UDP

TCP和UDP的区别以及应用场景
应用层协议  应用         传输层协议 应用层协议  应用         传输层协议
SMTP      电子邮件         TCP     DNS       域名转换       UDP
TELNET    远程终端接入      TCP    TFTP      文件传输       UDP
HTTP      万维网           TCP     SNMP      网络管理       UDP （网络管理应用程序通常在网络处于重压状态下，拥塞控制的TCP难以实现）
FTP       文件传输         TCP     NFS       远程文件服务器   UDP

TCP适用于效率要求低，但是准确性高或者有连接的场景；UDP适用于对效率要求高，但是对准确率要求低的场景。UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信.

首部格式：
UDP首部8字节 源端口 目的端口 数据长度 校验和
校验和：接收方使用校验和来检查报文段是否出现差错，它只有差错检验的功能，却不能实现差错恢复。

UDP首部20字节 源端口 目的端口 校验和
8字节序列号seq：给出发送方的序列号 8字节确认号ack：确定字节收到的数据，提供确认。 这两个字段提供了可靠传输。
接受窗口：用于流量控制，告诉对方目前可以接受的窗口大小。
标志字段，控制位：ACK表示ack中字段有效，SYN表示请求连接，FIN表示请求结束连接。 PSH指示接收方应立即上传数据给上层 URG表示报文段是紧急发送的
RST字段标示复位，用来异常的关闭连接：发送RST关闭连接，不用等缓冲区的包都发出去，接收方也不用发送ACK包确认
首部字段：TCP有选项字段，所以长度不固定。

TCP实现可靠传输
可靠：确保接收方进程读到的字节流和发送方发出的字节流是完全一样的，按序不丢失
校验和：确保收到的数据和发送的相同，没有出错，但不检测顺序。
序号机制：
为了实现TCP的可靠传输，有确认机制，接受放会对收到的报文段进行确认，发送给发送方，这样发送方才会发接下来的报文段。TCP是面向字节流的协议，
会对需要传送的字节进行编号，
累积确认：
接收方对当前接受到的最后一个字节进行确认。
重传：超时重传和冗余ACK重传
超时重传：发送方在规定时间内没有收到确认就要重传。采用自适应算法，计算加权平均往返时间RTTs
冗余ACK重传：超时重传可能等的时间太久，需要快速重传，接收方每当有比期待的序号大的报文段达到时，就发送一个冗余ACK，发送方收到连续三个
相同的ACK确认时，就意味着该报文段丢失，需要重传。
为什么是3次呢，因为两次ACK有可能是乱序，3次ACK很可能是丢包。

TCP实现流量控制：
主要通过滑动窗口机制来实现流量控制。接受方会发送一个接受窗口大小，发送方要根据该接受窗口调整自己的窗口大小。

TCP实现拥塞控制：
流量控制主要针对一个TCP连接，拥塞控制是整个网络的问题。
发送方发送窗口的大小是min（接收窗口，拥塞窗口）；
1）慢启动和拥塞避免
2）快重传和快恢复
在发生快速重传时，认为网络拥塞，然后将阈值减半，将拥塞窗口降到阈值处，而不是初始，这叫快恢复，然后线性增加


TCP最后客户端进入的TIME_WAIT状态的作用：为了确保对服务器端的FIN的ACK可以重传

SYN泛洪攻击 如何解决?
攻击者发送大量的TCP SYN报文段，服务器一旦收到该报文段，就会分配并初始化变量和缓存，服务器不断为这些半开连接分配资源，导致服务器资源被消耗殆尽。
解决方案：SYN cookie 当服务器收到一个SYN报文段时，并不会马上分配资源，而是生成一个初始TCP序号，该序列号是SYN报文段的源和目的IP与端口号以及仅有
该服务器知道的秘密数的一个复杂函数。这种初始序列号被成为cookie。 如果客户是合法的，会回应一个ACK，如何判断是之前的ACK的确认呢。 正常来说，这个序列
号应该是之前cookie + 1，运用这个特殊函数，就能生成之前的cookie，就能判定这个ACK是否是合法的，这时服务器在分配资源。

TCP粘包
TCP是流式协议，传递的是流水一样的字节流.TCP自己的协议头有长度，包含着头部，但是携带的报文段中的有效信息的长度不知道。这就会导致粘包。
连续向对端发送两个或两个以上的数据包时，对端一次收取收到的包数量可能大于1个，少于一个，可能是几个，这就是粘包。
处理粘包有3种方法
1）固定数据包的长度：每个数据包的长度固定，这样格式简单但是灵活性差。如果包的内容小于指定字节长度，需要填充特殊字符；如果包的内容多于指定字符长度，
需要分包分片。
2）以指定的字符为包的结束标志，http的结尾以\r\n表示。但是如果数据包中有这些结束标志符，就要对其进行转义操作。
3）包头+包体 包头是一个结构体，包头是固定大小的，里面有一个字段确定包体的大小。

TCP心跳包
两个场景
1）服务器和客户端之间的通路断了，此时两者之间没有信息交流，无法感知对方的连接是否正常，死链产生。
2）客户端和服务器相连后，很久没有数据来往，防火墙程序将连接关闭，但是我们不希望关闭。
这两种情况下都需要心跳包。在任意一端向对端发送一个数据包，可以检测是否正常。对于第一种情况，没有心跳包的回应，检测死链，对于第二种情况，
保活，确保这个连接是活动的。