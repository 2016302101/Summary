1.0 数据库分页

使用select时默认指定列的所有行都返回，返回具体的行要使用limit；
-- 在所有的查询结果中，返回前5行记录。 SELECT prod_name FROM products LIMIT 5; 
-- 在所有的查询结果中，从第5行开始，返回5行记录。 SELECT prod_name FROM products LIMIT 5,5;
但是当偏移量较大时，即LIMIT 10000,20 这样的查询，要查询10020条记录只返回最后20条，基本要访问大面积的页面。
1）将查询落到索引上
可以先查询索引，用索引覆盖扫描，不查询所有的列。
2）记录上一次查询的id，直接在此基础上limit

2.0 SQL中的聚合函数
COUNT()、AVG()、SUM()、MAX()、MIN()

COUNT()：
1）COUNT(*)计算表中总行数，不忽略空值（NULL）和是否有数据
2）COUNT(字段名)计算指定列下总行数，忽略空值（NULL）和没有数据的行

AVG()函数()：只能计算单列数值的平均值，自动忽略NULL

SUM()：指定列的总和

MAX()、MIN()：指定列的最大最小值

3.0 表跟表联系
内连接INNER JOIN：返回两张表满足连接条件的数据，不满足条件的数据不会查询出来

4.0 where和having的区别
where是约束声明，其约束来自用数据库，在分组之前起作用，不能使用聚合函数；
having是过滤声明，可以使用聚合函数
常规的子句的顺序：select，from，where，group by，having，order by，limit

5.0 表之间的连接关系
内连接：用inner join实现，返回两张表中满足连接条件的数据。 
自联结：有时候可以给同一个表两个别名，作为外部语句来替代从相同表中检索数据用的子查询语句。
外连接：用outer join实现，返回两张表中满足连接条件的数据，同时会返回满足不满足连接条件的数据。分为LEFT OUTER JOIN和RIGHT OUTER JOIN。左外连接返回左表所有行，右连接返回右表所有行。

索引

1.0 MySQL索引的理解
索引是单独存储在磁盘上的数据结构，包含数据库里所有记录的引用指针。使用索引就是为了可以加速查询，在使用SQL中查询语句的时候，比如where可以更快。
但是索引也有不好的地方，1）索引是实际存在的物理结构，需要占用磁盘空间，大的索引表是占很大的物理空间的；2）创建和维护索引是消耗时间的；3）当对表中的数据进行修改时，也要相应的对索引进行维护。

2.0 索引的种类
普通索引：最基本的索引，允许在定义索引的列中插入重复值和空值；
唯一索引：索引列的值必须唯一，允许有空值。主键索引是特殊的唯一索引，不允许有空值；
单列索引：只包含单个列； 组合索引：在表的多个字段组合上创建索引
全文索引：索引类型是FULLTEXT，支持值的全文查找

事务transaction：一组sql语句块，要不一起执行，如果有一个出错，就全部不执行。MYSQL中存储引擎实现事务。不是所有存储引擎都支持事务，InnoDB支持事务，MyIsam、Memory不支持。
https://www.cnblogs.com/kismetv/p/10331633.html
start transaction;
……  #一条或多条sql语句
commit;

start transaction标示事务开始，commit提交事务，将执行结果写入数据库。如果sql语句出问题，会直接调用rollback回到执行前。
MySQL默认的是autocommit，每一行命令都是一个事务，执行完就自动提交。事务下，关闭自动提交，遇到commit和rollback才开始另一个事务。
但是特殊操作除外，DDL语句(create table/drop table/alter/table)、lock tables语句会强制执行commit

事务的四大特性（ACID）
1）原子性Atomicity：一个事务是一个不可分割的工作单位，必须一气呵成执行完。
主要靠undo log日志实现，把命令一个个倒退
2）持久性Durability：事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。事务不会因为宕机等原因丢失数据
基于redo log，数据被修改时会记录到redo log中，宕机重启可以读取redo log中的数据，对数据库进行恢复。
3）隔离性Isolation：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰
4）一致性Consistency：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。








