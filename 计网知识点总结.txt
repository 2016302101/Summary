1 OSI七层参考模型
应用层，表示层，会话层，运输层，网络层，数据链路层，物理层。

2 TCP/IP五层参考模型
应用层，运输层，网络层，数据链路层，物理层。
每一层可以使用下一层的服务，同时为上一层提供服务。

应用层：
1，DNS域名系统
我们实际访问的不是IP地址，而是域名。DNS域名系统就是将域名转换成IP地址的系统。包括，本地域名服务器，根域名服务器，顶级和权限域名
服务器。可以采取递归和迭代两种方法进行查询。主机首先向本地域名服务器查询。

DNS域名系统既使用UDP又使用TCP。
大部分时候使用UDP，只有在以下两中情况使用TCP连接。
1）超过512字节的DNS响应报文；或者当UDP传输超了字节时使用TCP
2）区域传输时使用TCP。域名服务器分为主从两种，主服务器主要写，从服务器负责读，主从服务器实现数据同步时使用TCP。

2 FTP协议（了解）
文件传输协议，向公众提供文件拷贝服务，不要求事先登记注册，即可以匿名操作。使用TCP可靠连接。
FTP协议监听两个端口20，21。控制进程监听21端口，信息传输进程监听20端口。
控制连接：服务器端打开TCP21端口监听，客户端发送连接。
数据连接：1）主动方式：客户端发送连接请求，服务器通过TCP端口号20主动建立连接；
2）被动连接：客户端发送PASV命令，告诉服务器进入被动模式。服务器旋转临时端口，客户端主动与服务器段建立连接。
有两种传输模式，文本传输和二进制序列传输。

3 关于HTTP协议
HTTP协议大多数情况下都是文本形式的明文格式，所以是text文本的协议。
由包头（1-7行）和包体（7行以后）组成。
请求报文：
GET/POST URL路径 HTTP版本协议号 \r\n
Host：。。。。\r\n （请求的主机名）
Connection：。。。\r\n （连接方式）
User-Agent：。。。\r\n（产生请求的浏览器类型）
Accept：。。。\r\n （客户端可识别的内容类型列表）
\r\n

包头和包体由\r\n区分开

响应报文：用状态码代替URL，其余相同。

GET，POST, PUT, DELETE （查，增，改，删）
GET：请求服务器上的资源，不对其进行修改。安全和幂等的。
POST: 向服务器提交数据，修改资源。比如评论某个新闻。增加的资源存放位置由服务器决定。
PUT: 向服务器提交数据，但是增加的资源存放位置指定了。
DELETE：删除某一资源。
HEAD: 不含有呈现数据，仅仅判断该资源是否存在。

HTTP1.1 比 HTTP1.0提高：
1）1.1引入了更多的缓存处理； 2）1.1优化了带宽和网络连接：
3）错误通知：1.1新增了24个错误状态相应码；
4）host头处理：1.0中默认一个主机只有一个IP，但是虚拟主机技术出现，导致一个物理服务器可以有多个虚拟主机，
它们共享一个IP，如果没有host主域，会报错。
5）长连接：1.1支持长连接和流水线处理，在一个TCP上可以传送多个HTTP请求和响应，keep-alive。

HTTPs 和 HTTP的区别
HTTPs在HTTP的基础上加入了SSL/TLS进行加密和解密。且HTTPS端口号是80，HTTP是40。
HTTPs加密流程 https://segmentfault.com/a/1190000021494676

cookie和session的区别
HTTP协议本身是无状态的。Cookie是存储在浏览器上的一小段文本信息，记录用户之前的浏览记录。浏览器再次请求该网站时，
浏览器会把cookie也发给服务器。服务器检查到cookie，判断用户状态，推荐用户感兴趣的信息。
session也是一种记录用户状态的机制，但是session存储在服务器上。更加安全，而且存储容量更大。

HTTP2.0的提高
1）新的二进制格式：1的版本是基于文本，文本协议表现形式很多，不够健壮。2.0采用二进制格式，更健壮。
2）多路复用：2.0的连接可以同时发起多重的请求-响应消息，连接共享。每个request有自己的id，一个连接上可以
有多个request同时多路复用，减少了TCP建立连接的开销。
3）header压缩：1版本的header带有大量信息，每次都要重复发送。2.0对header数据进行压缩，通讯双方各自缓存
一份header fields表，差量更新HTTP头部，避免了header的重复传输，减少了需要传输的大小。
4）服务端推送：在客户端请求之前就发送数据。服务端在发送HTML页面时就主动推送其他资源，将这些资源存到客户端本地。

4 运输层 TCP和UDP

TCP和UDP的区别以及应用场景
应用层协议  应用         传输层协议 应用层协议  应用         传输层协议
SMTP      电子邮件         TCP     DNS       域名转换       UDP
TELNET    远程终端接入      TCP    TFTP      文件传输       UDP
HTTP      万维网           TCP     SNMP      网络管理       UDP （网络管理应用程序通常在网络处于重压状态下，拥塞控制的TCP难以实现）
FTP       文件传输         TCP     NFS       远程文件服务器   UDP

TCP适用于效率要求低，但是准确性高或者有连接的场景；UDP适用于对效率要求高，但是对准确率要求低的场景。UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信.

首部格式：
UDP首部8字节 源端口 目的端口 数据长度 校验和
校验和：接收方使用校验和来检查报文段是否出现差错，它只有差错检验的功能，却不能实现差错恢复。

UDP首部20字节 源端口 目的端口 校验和
8字节序列号seq：给出发送方的序列号 8字节确认号ack：确定字节收到的数据，提供确认。 这两个字段提供了可靠传输。
接受窗口：用于流量控制，告诉对方目前可以接受的窗口大小。
标志字段，控制位：ACK表示ack中字段有效，SYN表示请求连接，FIN表示请求结束连接。 PSH指示接收方应立即上传数据给上层 URG表示报文段是紧急发送的
RST字段标示复位，用来异常的关闭连接：发送RST关闭连接，不用等缓冲区的包都发出去，接收方也不用发送ACK包确认
首部字段：TCP有选项字段，所以长度不固定。

TCP实现可靠传输
可靠：确保接收方进程读到的字节流和发送方发出的字节流是完全一样的，按序不丢失
校验和：确保收到的数据和发送的相同，没有出错，但不检测顺序。
序号机制：
为了实现TCP的可靠传输，有确认机制，接受放会对收到的报文段进行确认，发送给发送方，这样发送方才会发接下来的报文段。TCP是面向字节流的协议，
会对需要传送的字节进行编号，
累积确认：
接收方对当前接受到的最后一个字节进行确认。
重传：超时重传和冗余ACK重传
超时重传：发送方在规定时间内没有收到确认就要重传。采用自适应算法，计算加权平均往返时间RTTs
冗余ACK重传：超时重传可能等的时间太久，需要快速重传，接收方每当有比期待的序号大的报文段达到时，就发送一个冗余ACK，发送方收到连续三个
相同的ACK确认时，就意味着该报文段丢失，需要重传。
为什么是3次呢，因为两次ACK有可能是乱序，3次ACK很可能是丢包。

TCP实现流量控制：
主要通过滑动窗口机制来实现流量控制。接受方会发送一个接受窗口大小，发送方要根据该接受窗口调整自己的窗口大小。

TCP实现拥塞控制：
流量控制主要针对一个TCP连接，拥塞控制是整个网络的问题。
发送方发送窗口的大小是min（接收窗口，拥塞窗口）；
1）慢启动和拥塞避免
2）快重传和快恢复
在发生快速重传时，认为网络拥塞，然后将阈值减半，将拥塞窗口降到阈值处，而不是初始，这叫快恢复，然后线性增加


TCP最后客户端进入的TIME_WAIT状态的作用：为了确保对服务器端的FIN的ACK可以重传

SYN泛洪攻击 如何解决?
攻击者发送大量的TCP SYN报文段，服务器一旦收到该报文段，就会分配并初始化变量和缓存，服务器不断为这些半开连接分配资源，导致服务器资源被消耗殆尽。
解决方案：SYN cookie 当服务器收到一个SYN报文段时，并不会马上分配资源，而是生成一个初始TCP序号，该序列号是SYN报文段的源和目的IP与端口号以及仅有
该服务器知道的秘密数的一个复杂函数。这种初始序列号被成为cookie。 如果客户是合法的，会回应一个ACK，如何判断是之前的ACK的确认呢。 正常来说，这个序列
号应该是之前cookie + 1，运用这个特殊函数，就能生成之前的cookie，就能判定这个ACK是否是合法的，这时服务器在分配资源。

TCP粘包
TCP是流式协议，传递的是流水一样的字节流.TCP自己的协议头有长度，包含着头部，但是携带的报文段中的有效信息的长度不知道。这就会导致粘包。
连续向对端发送两个或两个以上的数据包时，对端一次收取收到的包数量可能大于1个，少于一个，可能是几个，这就是粘包。
处理粘包有3种方法
1）固定数据包的长度：每个数据包的长度固定，这样格式简单但是灵活性差。如果包的内容小于指定字节长度，需要填充特殊字符；如果包的内容多于指定字符长度，
需要分包分片。
2）以指定的字符为包的结束标志，http的结尾以\r\n表示。但是如果数据包中有这些结束标志符，就要对其进行转义操作。
3）包头+包体 包头是一个结构体，包头是固定大小的，里面有一个字段确定包体的大小。

TCP心跳包
两个场景
1）服务器和客户端之间的通路断了，此时两者之间没有信息交流，无法感知对方的连接是否正常，死链产生。
2）客户端和服务器相连后，很久没有数据来往，防火墙程序将连接关闭，但是我们不希望关闭。
这两种情况下都需要心跳包。在任意一端向对端发送一个数据包，可以检测是否正常。对于第一种情况，没有心跳包的回应，检测死链，对于第二种情况，
保活，确保这个连接是活动的。

路由器和交换机区别：
工作层次不同：
交换机工作在数据链路层，路由器工作在网络层。
转发依据不同：
交换机转发依据的对象是MAC地址（物理地址），路由器转发依据的是IP地址（网络地址）
主要功能不同：
交换机主要用于组建局域网，路由器将交换机组好的局域网互相连接起来。

UDP的可靠传输
很多时候我们既需要UDP的实时性，又需要TCP的可靠传输，只能再UDP的基础上实现可靠传输。TCP增大时延和传输成本保证通信质量，UDP牺牲质量降低成本和时延。
RUDP的价值在于根据不同的传输场景进行不同的技术选型，核心在于平衡成本，时延和质量三方面。
可靠的定义很多：
1）尽力可靠：接收方要求发送方的数据尽量完整到达，但业务本身的数据是可以允许缺失，音视频数据；
2）无序可靠：接收方要求发送方的数据必须完整到达，但可以不管到达先后顺序。文件传输，白板书写
3）有序可靠：接收方要求发送方的数据必须按顺序完整到达
RTT和RTO的计算：RTT（round trip time）发送和收到ack包之间的时间。 RTO：发送一个数据包之后的重传时间，即重传定时器的时间，需要预估这个时间

通过发送端收到的ACK的丢包信息来进行反馈。3种重传：定时重传，请求重传和FEC重传
定时重传：如果数据包发送之后一个RTO之后ACK还没到达，需要重传该数据包，这样需要依靠RTO的计算。
如果是一个对延迟敏感但是对流量成本要求不高，可以将RTO设置的很小，尽可能保证时延小，操作网游和书写同步。
请求重传：接收端在发送ACK时携带自己丢失报文的信息反馈，发送端页这样操作。请求重传比定时重传的延迟更大，适合带宽大的传输场景，比如视频，文件传输，视频同步
FEC（Forward Error Correction）选择重传：发送包时，把几个报文进行FEC分组，通过异或方式得到若干个冗余包，一起发往接收端。如果发生丢失但是可以通过FEC分组算法
还原，就不向发送端请求重传，如果不能恢复再请求重传，如果带宽不充裕，会使网络环境更差。

窗口的滑动操作：
如果需要可靠有序，接收端要做好窗口的排序和缓冲。如果不严格要求有序，则不需要这样，可以将编号靠后但是先到的包先给上层业务进行处理。

网络层

数据链路层
https://www.zhihu.com/question/21546408
MTU（最大传输单元）：通过物理网络能接受的最大的数据报的字节长度，超过这个长度，数据报就要进行分片操作。

MAC地址：互联网中，每个设备自身的唯一标识符，通信时确认身份的依据。
集线器：物理层设备，只是把电信号转发到所有出口(广播)
交换机：数据链路层设别，MAC地址与指定的端口对应，可以起到分发的作用，把数据发送到对应的MAC地址，交换机维护一张MAC地址表，记录每一个MAC地址和端口的对应关系
路由器：网络层设备。如果MAC地址较多，端口就较多，这是实现不了的。路由器有自己的MAC地址，可以把数据包做一次转发。

为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？
MAC地址是固定的 48位构成，厂商自己烧录的，很难统一。如果想要快速交换信息，比如使用路由器，就必须在软件层面上再给出一个地址，这就是IP地址。
使用32位的地址，然后分成4部分，点分十进制。这样就可以实现自己规划的网络拓扑结构。

网络层转发数据报的流程：
交换机用于同一个子网下，路由器负责不同子网通信。
如果是同一子网设备进行通信，网络层并没有体现出用处，因为只需要找到对应的MAC地址即可
192.168.0.1 和 192.168.0.2 处于同一个子网
192.168.0.1 和 192.168.1.1 处于不同子网
子网划分 子网掩码：计算机如何知道目的IP是否是与我在同一子网，就需要使用子网掩码，比如255.255.255.0。将源IP和目的IP分别于子网掩码进行与运输，相等就是一个子网，
不相等就不是

如果是不同局域网通信，发送方的源IP和目的IP是不变的，但是数据链路层的目的MAC地址需要设置为子网的路由器MAC地址，将该数据包发送给路由器，接下来的事情就交给路由器
处理。子网中的每个主机会有一个默认网关，就是路由器的IP地址。这样就能找到路由器
路由器如何知道接收方的地址呢？
路由器和接收机类似，接收机的每个端口对应这MAC地址，路由器的每个端口对应一个子网，根据目的地址和子网掩码可以得到目的地址的子网
地址解析协议 ARP：客户端发送消息时，会指定接收方的IP地址，但是在数据链路层传输时需要知道对方的MAC地址。ARP就是根据IP地址翻译成MAC地址的协议。
每台主机里有一张ARP缓存表，记录着IP和MAC地址的对应关系。一开始这个表是空的，如果A想知道B的地址，就会广播一条ARP请求，B收到请求就会带上自己的MAC地址给A一个响应，更新自己的ARP表。
ARP四种典型情况
1）主机A发给本网络的主机B：用ARP直接找到主机B的mac地址，直接广播就行
2）主机A发给另一网络的主机B：用ARP找到本网默认网关（路由器）的mac地址
3）路由器发给本网络的主机A：用ARP找到主机A的mac地址
4）路由器发给另一个网络的主机B:用ARP找到下一跳路由器的MAC地址

从以下三个角度看网络层传输数据报过程
从电脑视角：
1）首先我要知道我自己的IP和对方的IP
2）通过子网掩码判断我们是否在同一子网
3）在同一个子网就通过ARP获取对方的MAC地址直接发过去
4）如果不在同一个子网就通过ARP获取默认网关（路由器）的MAC地址交给路由器处理

从交换机视角：
在同一个子网里发送数据，接收到的数据报的MAC地址就在自己这个子网
通过MAC地址表就能查到对应的端口，发送就完事了

从路由器视角：
收到的数据报是带有目的IP地址的
通过路由表查到映射关系，得到目的IP地址对应的子网的端口
如果查表查到了就从知道端口发出去
查不到就返回一个路由不可达的数据包

总结起来：网络层（IP协议）本身没有传输包的功能，包的传输是数据链路层实现的
涉及到三张表：
ARP缓存表：在本机上，存储IP和mac地址的映射关系，不断通过ARP协议的请求完善，高速缓存更新很快
MAC地址表：交换机不断通信进行更新，在同一个网络内，存储着MAC地址和端口的映射关系
路由表：路由算法+人工配置，在路由器上，主要包括目的IP 子网掩码 下一跳IP地址 端口

网络地址转换NAT：
路由器对目的地址是私有IP地址的数据报是不转发的。在专用网和因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。NAT路由器有自己的转换表WAN端对应LAN端，因特网对应专用网。

网络控制报文协议ICMP：
支持主机或路由器的差错或异常报告和网络探寻。对于出错的报文，在网络层丢弃后，要发送特定的ICMP报文。
以下5种情况发送ICMP报文：
1）终点不可达：路由器或者主机不能交付数据报就向源点发送终点不可达报文
2）源点抑制：由于拥塞丢弃数据报，向源点发送原点抑制报文，让源点减慢发送速度
3）时间超过：路由器收到的生存时间TTL = 0的数据报，丢弃并发送时间超过报文。如果接收方在预先规定的时间没有收到数据报全部数据时丢弃，发送时间超过报文
4）参数问题：数据报首部字段不正确，丢弃发送参数问题报文
5）改变路由：路由器把改变路由报文发送给主机，让主机知道下次应把数据报发送给另外的路由器

